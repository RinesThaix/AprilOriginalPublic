# April

## Idea
Project April is an API invented for annotation-based approach in creating distributed services.
It allows you to easily execute remote procedure calls between different nodes.

## Terminology:
#### Remote procedure = Remote method/function
Procedure (method/function) which execution is delegated to a **Data Producer** (most commonly, on other physical machine) via the **Distribution server**
#### Node
**Data Retriever**, **Distributor** or **Data Producer**
#### Data Retriever
Application containing **Remote procedures** delegated to **Distributor**.
Multiple may occur optionally joined by a single **Data network**.
#### Distributor
Server that is responsible for accepting requests for **Remote procedure** execution, processing them to **Data Producers** and returning the result (if any).
As a normal practice, it is recommented to have at least 3 of them in a single **Data network**.
When there are multiple of them, they will connect to each other to share the data and load.
#### Data Producer
Application that is responsible for execution of **Remote procedures** for whom they are local.
Multiple may occur optionally joined by a single **Data network**.
#### (Data )network
Group of **Data Retrievers**, **Distributors** and **Data Producers** joined for cooperative work.
#### Data(flow)
Stream of data between **Data Retrievers**, **Distributors** and **Data Producers**. Normally goes from the first to the last and backwards.

## API
### Shared
#### Node internal UUID:
Object unique for each node in a **Network** used for its identification amongst others.
#### Node name `April.getInstanceName()`
Unique string identifier for each node in a **Network**. Automatically generated by **Distributor** after node connects to it.
Consists of char- and numeric- parts: first one is being generated based on ip address of the node, the second one is random.

### On Data Retrievers
#### Retriever interface
It is just an interface describing methods of **Remote procedures**.
May contain non-**Remote procedures** methods defined as `default`.
All of this interfaces must be marked with `@Retriever` annotation, in which you can specify:
- producer name (which will lead to **Data Producers** registered with the exactly the same name for **Remote procedure calls** execution);
- timeout for those calls which require any response from **Data Producers**;
- whether you want to use (when possible) only one randomly selected **Data Producer** across all instances with same producer name.
#### Method annotation `@ProducerMethodName`
Initially, interface method will generate **Remote procedure call** to the method of **Data Producer** with exactly the same name.
This annotation allows you to specify another method to be executed on **Data Producer** side.
Keep in mind, that you can create methods with `ListenableFuture<T>` return type and `future` (in any case) suffix that will be truncated not to use this annotation.
#### Method annotation `@AllInstancesMethod`
If your method is of void return type, you can mark it with that annotation to make it execute on call on all instances of **Data Producers** with producer name of your **Data Retriever**.
Without this annotation, method will be executed only on a single instance of such a **Data Producer** (if there are any).
#### Method annotation `@Cacheable`
Allows you not to send **Remote procedure calls** across the network all the time you call a method.
Using that annotation, you can cache the result of method invocation with exactly the same arguments for specified amount of time.
#### Method annotation `@Retriable`
Can be used only on synchronous methods.
Whether execution of **Remote procedure call** ended up with a timeout or could not find an executor (**Data Producer** with required producer's name), will retry for given amount of times sleeping between them by given amount of time.
If after all it didn't succeed, throws exception anyways.
#### Method argument annotation `@ExactInstanceName String`
Whether you have a method for which you want to select the exact instance of **Data Producer** on which **Remote procedure** will be executed on, you can use that annotation.
The value of it is a **Node name** of **Data Producer** instance.
Can be present only once in method signature.
#### Method argument annotation `@IndexField`
Can be used multiple times in method signature.
Creates an index using all marked arguments that will be used by **Distributors** to select **Data Producer** on which **Remote procedures** will be executed.
In other words, allows you to force **Remote procedures** execution with same indexed fields on same **Data Producer** instances.
#### Methods return types
There are currently 3 types of **Remote procedures** you can create using this API:
- Asynchronous non-result call: just use `void` as a return type for your method;
- Synchronous result call: use anything rather than `void` and `ListenableFuture<T>` as a return type. If return type is a custom object, it must be in the same package on **Data Retriever** and **Data Producer** sides and have exactly the same fields.
- Asynchronous result call: use `ListenableFuture<T>` as a return type.

### On Distributors
Actually, there is no API for them. You just setup configuration file and launch them.
They will do all their work by themselves.

### On Data Producers
#### Producer implementation
It is just a class that implements logic of **Remote procedures**.
All of this classes must contain no-args constructor and must be marked with `@Producer` annotation, in which you can specify that producer's name.
#### Methods return types
Please, keep in mind that you are not allowed to use any kind of futures as a return types of your methods.
You also not allowed to use primitive wrappers (i.e. Integer instead of int) as a return type.

## Known bugs and TODOs of AprilOriginal
#### Node names collision
As for now, node names are being generated by **Data Producers** and, as mentioned above, generated in the following way: the first part, which consists of latin characters, generated based on node ip address; the second part is a random number up to 1 million. So, whether there are 100 nodes on a single ip address trying to simultaneously connect to different **Distributors**, there is a 100/1000000 = 0.01% chance of name collision. Currently it is handled nohow.
#### Slow method invocation on **Data Producer** side
It is not noticeable if you don't have _really_ lots of **Remote procedure calls** to the same **Data Producer**, but currently method invocation on their side is being processed using `Java Reflection API`, which is pretty slow. I'm looking into rewriting it using autogenerated lambdas by `LambdaMetafactory`.
#### Possible decrease in consumed memory
Currently a lot of internal data (i.e. method signatures and `@Cacheable` keys, generated based on arguments passed) that actually represents bunch of integers is being stored in strings. Rewriting this will slightly reduce amount of consumed memory.
#### Synchronous non-result methods
Currently methods with `ListenableFuture<Void>` return type are not supported, but it is planned to do so.